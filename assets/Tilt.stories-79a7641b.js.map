{"version":3,"file":"Tilt.stories-79a7641b.js","sources":["../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react/jsx-runtime.js","../../src/lib/utility/utility.ts","../../src/lib/index.tsx"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","// react\r\nimport { RefObject } from 'react';\r\n\r\n// types\r\nimport {\r\n  SpotGlarePosition,\r\n  LineGlareHoverPosition,\r\n  Offset,\r\n} from '../types/types';\r\n\r\n// limits number to be in [start - end] range\r\nexport const limitToRange = (\r\n  num: number,\r\n  start: number,\r\n  end: number\r\n): number => {\r\n  if (num < start) return start;\r\n  if (num > end) return end;\r\n  return num;\r\n};\r\n\r\n// calculates opacity of the spot glare element\r\nexport const getSpotGlareOpacity = (\r\n  offset: Offset,\r\n  spotGlarePosition: SpotGlarePosition,\r\n  spotGlareMaxOpacity: number\r\n): string => {\r\n  let opacityNum = 0;\r\n\r\n  if (spotGlarePosition === 'top')\r\n    /*\r\n     *  when hovering from the top (offsetY = 0) to half of height (offsetY = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetY to opacity => [0 - 0.5] to [1 - 0]\r\n     *  * 2 = [0 - 1] -> - 1 = [-1 - 0] -> * -1 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetY * 2 - 1) * -1;\r\n  else if (spotGlarePosition === 'bottom')\r\n    /*\r\n     *  when hovering from the bottom (offsetY = 1) to half of height (offsetY = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetY to opacity => [1 - 0.5] to [1 - 0]\r\n     *  - 0.5 = [0.5 - 0] -> * 2 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetY - 0.5) * 2;\r\n  else if (spotGlarePosition === 'left')\r\n    /*\r\n     *  when hovering from the left (offsetX = 0) to half of width (offsetX = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetX to opacity => [0 - 0.5] to [1 - 0]\r\n     *  * 2 = [0 - 1] -> - 1 = [-1 - 0] -> * -1 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetX * 2 - 1) * -1;\r\n  else if (spotGlarePosition === 'right')\r\n    /*\r\n     *  when hovering from the right (offsetX = 1) to half of width (offsetX = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetX to opacity => [1 - 0.5] to [1 - 0]\r\n     *  - 0.5 = [0.5 - 0] -> * 2 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetX - 0.5) * 2;\r\n\r\n  // limit opacity to spotGlareMaxOpacity\r\n  return (opacityNum * spotGlareMaxOpacity).toFixed(2);\r\n};\r\n\r\n// calculates position of the spot glare element\r\nexport const getSpotGlareTransform = (\r\n  offset: Offset,\r\n  spotGlarePosition: SpotGlarePosition,\r\n  spotGlareReverse: boolean\r\n): string => {\r\n  let offsetX = offset.offsetX;\r\n  let offsetY = offset.offsetY;\r\n\r\n  // reverse check\r\n  if (!spotGlareReverse) {\r\n    offsetX = 1 - offsetX;\r\n    offsetY = 1 - offsetY;\r\n  }\r\n\r\n  let transform = 'translateX(0deg) translateY(0deg)';\r\n\r\n  if (spotGlarePosition === 'top')\r\n    /*\r\n     *  when hovering from left (offsetX = 0) to right (ofsetX = 1)\r\n     *  translateX should be changing from 0 to 50% (because the spot glare element\r\n     *  is twice the size of the element and translate is relative to its size)\r\n     *  map offsetX to translateX => [0 - 1] to [0 - 50]\r\n     *  / 2 = [0 - 0.5] -> * 100 = [0 - 50] ->= ( * 50 )\r\n     */\r\n    transform = `translateX( ${offsetX * 50}% )`;\r\n  else if (spotGlarePosition === 'bottom')\r\n    // similar to above but translateY should be 50% to move it to the bottom\r\n    transform = `translateX( ${offsetX * 50}% ) translateY(50%)`;\r\n  else if (spotGlarePosition === 'left')\r\n    /*\r\n     *  when hovering from top (offsetY = 0) to bottom (ofsetY = 1)\r\n     *  translateY should be changing from 0 to 50% (because the glare element\r\n     *  is twice the size of the element and translate is relative to its size)\r\n     *  map offsetY to translateY => [0 - 1] to [0 - 50]\r\n     *  / 2 = [0 - 0.5] -> * 100 = [0 - 50] ->= ( * 50 )\r\n     */\r\n    transform = `translateY( ${offsetY * 50}% )`;\r\n  else if (spotGlarePosition === 'right')\r\n    // similar to above but translateX should be 50% to move it to the right\r\n    transform = `translateX(50%) translateY( ${offsetY * 50}% ) `;\r\n\r\n  return transform;\r\n};\r\n\r\n// calculates position of the spot glare element\r\nexport const getLineGlareTransform = (\r\n  offset: Offset,\r\n  lineGlareHoverPosition: LineGlareHoverPosition,\r\n  lineGlareReverse: boolean\r\n): string => {\r\n  let offsetX = offset.offsetX;\r\n  let offsetY = offset.offsetY;\r\n\r\n  // adjusting offsets based on hover position\r\n  if (lineGlareHoverPosition === 'top-right') offsetX = 1 - offsetX;\r\n  if (lineGlareHoverPosition === 'bottom-left') offsetY = 1 - offsetY;\r\n  if (lineGlareHoverPosition === 'bottom-right') {\r\n    offsetX = 1 - offsetX;\r\n    offsetY = 1 - offsetY;\r\n  }\r\n\r\n  let translateX = 0;\r\n\r\n  if (!lineGlareReverse)\r\n    /*\r\n     *  - line glare should be moving from translateX:-100% to 50% to\r\n     *    give the impression of moving over the element (since it's double the size\r\n     *    and translate is relative to size of the line glare not the parent element)\r\n     *\r\n     *  - the range of (offsetX + offsetY) is [0 - 2] but because line glare should\r\n     *    only be visible when hovering over the top-left part of the image,\r\n     *    we only need to map half the range ([0 - 1]).\r\n     *\r\n     *  - line glare should enter the element when hovering at center (offsetX + offsetY = 1),\r\n     *    and exit the element when hovering over the corner (offsetX + offsetY = 0), so\r\n     *    we need to map [1 - 0] to [-100 - 50] not [0 - 1].\r\n     *\r\n     *  - to map [1 - 0] to [-100 - 50]:\r\n     *    * -1 = [-1 - 0] -> * 3/2 = [-1.5 - 0] -> + 0.5 = [-1 - 0.5] -> * 100 = [-100 - 50]\r\n     */\r\n    translateX = ((offsetX + offsetY) * (-3 / 2) + 0.5) * 100;\r\n  /*\r\n   *  when reversed, we need to map [0 - 1] instead.\r\n   *  map [0 - 1] to [-100 - 50]:\r\n   *  * 3/2 = [0 - 1.5] -> - 1 = [-1 - 0.5] -> * 100 = [-100 - 50]\r\n   */ else translateX = ((offsetX + offsetY) * (3 / 2) - 1) * 100;\r\n\r\n  return `translateX(${translateX}%)`;\r\n};\r\n\r\n// gets HTMLElement from the union\r\nexport const getHTMLElement = (\r\n  el: HTMLElement | RefObject<HTMLElement> | Document\r\n): HTMLElement | undefined => {\r\n  // if it's an HTMLElement, return it\r\n  if (el instanceof HTMLElement) return el;\r\n\r\n  // if it's the document, case it to HTMLElement and return it\r\n  if (el instanceof Document) return document as unknown as HTMLElement;\r\n\r\n  // if it's a \"RefObject\" and \"ref.current\" is not null, return it\r\n  if (el.current) return el.current;\r\n\r\n  // otherwise, return undefined\r\n  return undefined;\r\n};\r\n","// react\r\nimport {\r\n  useEffect,\r\n  useRef,\r\n  useCallback,\r\n  useMemo,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  PropsWithChildren,\r\n  RefObject,\r\n} from 'react';\r\n\r\n// utility\r\nimport {\r\n  limitToRange,\r\n  getSpotGlareOpacity,\r\n  getSpotGlareTransform,\r\n  getLineGlareTransform,\r\n  getHTMLElement,\r\n} from './utility/utility';\r\n\r\n// types\r\nimport { TiltProps, TiltRef, Position, Angle, Offset } from './types/types';\r\n\r\nexport const Tilt = forwardRef<TiltRef, TiltProps>(\r\n  (\r\n    {\r\n      width,\r\n      height,\r\n      borderRadius,\r\n      perspective = '1000px',\r\n      scale = 1,\r\n      lineGlareEnable = true,\r\n      lineGlareBlurEnable = true,\r\n      lineGlareBlurAmount = '4px',\r\n      lineGlareMaxOpacity = 0.1,\r\n      lineGlareWidthPercent = 10,\r\n      lineGlareMixBlendMode = 'normal',\r\n      lineGlareColor = 'white',\r\n      lineGlareReverse = false,\r\n      lineGlareDirection = 'to-bottom-right',\r\n      lineGlareHoverPosition = 'top-left',\r\n      spotGlareEnable = true,\r\n      spotGlareMaxOpacity = 0.5,\r\n      spotGlareMixBlendMode = 'normal',\r\n      spotGlarePosition = 'top',\r\n      spotGlareColor = 'white',\r\n      spotGlareReverse = false,\r\n      tiltMaxAngleX = 20,\r\n      tiltMaxAngleY = 20,\r\n      tiltReverse = false,\r\n      tiltReset = true,\r\n      initialAngleX = 0,\r\n      initialAngleY = 0,\r\n      disableScrollOnTouch = true,\r\n      style,\r\n      tiltStyle,\r\n      tiltProps,\r\n      gyroMaxAngleX = 0,\r\n      gyroMaxAngleY = 0,\r\n      gyroReverse = false,\r\n      disabled = false,\r\n      disabledFilter = 'grayscale(1) brightness(125%)',\r\n      CSSTransition = 'all 0.4s cubic-bezier(0.03, 0.98, 0.52, 0.99)',\r\n      TiltWrapper = ({ children }: PropsWithChildren) => <>{children}</>,\r\n      fullPageListening = false,\r\n      controlElement,\r\n      controlElementOnly = false,\r\n      testIdEnable = false,\r\n      onTilt,\r\n      onMouseEnter,\r\n      onMouseMove,\r\n      onMouseLeave,\r\n      onTouchStart,\r\n      onTouchMove,\r\n      onTouchEnd,\r\n      onBlur,\r\n      children,\r\n      ...props\r\n    }: TiltProps,\r\n    ref\r\n  ) => {\r\n    // state variables (non-re-rendering)\r\n    const offset = useRef<Offset>();\r\n    const isBeingTouchedOrHovered = useRef(false);\r\n    const attachEvents =\r\n      !fullPageListening &&\r\n      (!controlElement || (controlElement && !controlElementOnly));\r\n\r\n    // elements\r\n    const containerRef = useRef<HTMLDivElement | null>(null);\r\n    const tiltRef = useRef<HTMLDivElement>(null);\r\n    const spotGlareRef = useRef<HTMLDivElement>(null);\r\n    const lineGlareRef = useRef<HTMLDivElement>(null);\r\n\r\n    // line glare width check\r\n    if (lineGlareEnable) {\r\n      // halving width because the percentage is applied to the\r\n      // line glare element which is twice the size\r\n      lineGlareWidthPercent = limitToRange(lineGlareWidthPercent, 0, 50) / 2;\r\n    }\r\n\r\n    // limit max angles to [0 - 90]\r\n    tiltMaxAngleX = limitToRange(tiltMaxAngleX, 0, 90);\r\n    tiltMaxAngleY = limitToRange(tiltMaxAngleY, 0, 90);\r\n    gyroMaxAngleX = limitToRange(gyroMaxAngleX, 0, 90);\r\n    gyroMaxAngleY = limitToRange(gyroMaxAngleY, 0, 90);\r\n\r\n    // limit initial angles to max angle\r\n    if (initialAngleX)\r\n      initialAngleX = limitToRange(\r\n        initialAngleX,\r\n        -tiltMaxAngleX,\r\n        tiltMaxAngleX\r\n      );\r\n    if (initialAngleY)\r\n      initialAngleY = limitToRange(\r\n        initialAngleY,\r\n        -tiltMaxAngleY,\r\n        tiltMaxAngleY\r\n      );\r\n\r\n    // line glare variables\r\n    const lineGlareStart = useMemo(() => {\r\n      return lineGlareEnable ? (100 - lineGlareWidthPercent) / 2 : 0;\r\n    }, [lineGlareEnable, lineGlareWidthPercent]);\r\n    const lineGlareEnd = useMemo(() => {\r\n      return lineGlareEnable ? lineGlareStart + lineGlareWidthPercent : 0;\r\n    }, [lineGlareEnable, lineGlareWidthPercent, lineGlareStart]);\r\n\r\n    // functions\r\n\r\n    // updates spot glare element's transform and opacity\r\n    const updateSpotGlare = useCallback((): void => {\r\n      if (!containerRef.current || !spotGlareRef.current || !offset.current)\r\n        return;\r\n\r\n      const opacity = getSpotGlareOpacity(\r\n        offset.current,\r\n        spotGlarePosition,\r\n        spotGlareMaxOpacity\r\n      );\r\n\r\n      const transform = getSpotGlareTransform(\r\n        offset.current,\r\n        spotGlarePosition,\r\n        spotGlareReverse\r\n      );\r\n\r\n      requestAnimationFrame(() => {\r\n        if (spotGlareRef.current) {\r\n          spotGlareRef.current.style.opacity = opacity;\r\n          spotGlareRef.current.style.transform = transform;\r\n        }\r\n      });\r\n    }, [spotGlarePosition, spotGlareMaxOpacity, spotGlareReverse]);\r\n\r\n    // updates line glare element's transform\r\n    const updateLineGlare = useCallback((): void => {\r\n      if (!containerRef.current || !lineGlareRef.current || !offset.current)\r\n        return;\r\n\r\n      const transform = getLineGlareTransform(\r\n        offset.current,\r\n        lineGlareHoverPosition,\r\n        lineGlareReverse\r\n      );\r\n\r\n      requestAnimationFrame(() => {\r\n        if (lineGlareRef.current)\r\n          lineGlareRef.current.style.transform = transform;\r\n      });\r\n    }, [lineGlareHoverPosition, lineGlareReverse]);\r\n\r\n    // calculates tilt angle from offset\r\n    const getAngleFromOffset = useCallback(\r\n      (applyTiltReverse = true): Angle => {\r\n        if (!containerRef.current || !offset.current)\r\n          return { angleX: 0, angleY: 0 };\r\n\r\n        // mapping offset to angle => [0 - 1] to [-angle - angle]\r\n        // - 0.5 = [-0.5 - 0.5] -> * 2 = [-1 - 1] -> * angle = [-angle - angle]\r\n        let angleX = -(offset.current.offsetY - 0.5) * 2 * tiltMaxAngleX;\r\n        let angleY = (offset.current.offsetX - 0.5) * 2 * tiltMaxAngleY;\r\n\r\n        if (tiltReverse && applyTiltReverse) {\r\n          angleX = -angleX;\r\n          angleY = -angleY;\r\n        }\r\n\r\n        return { angleX, angleY };\r\n      },\r\n      [tiltMaxAngleX, tiltMaxAngleY, tiltReverse]\r\n    );\r\n\r\n    // sets offset based on tilt angle\r\n    const setOffsetFromAngle = useCallback(\r\n      (angle: Angle): void => {\r\n        // mapping (angleX/Y / tiltMaxAngleX/Y) to offset = [-1 - 1] to [0 - 1]\r\n        // + 1 = [0 - 2] -> / 2 = [0 - 1]\r\n        const offsetX = (angle.angleY / tiltMaxAngleY + 1) / 2;\r\n        const offsetY = (-angle.angleX / tiltMaxAngleX + 1) / 2;\r\n\r\n        offset.current = { offsetX, offsetY };\r\n      },\r\n      [tiltMaxAngleX, tiltMaxAngleY]\r\n    );\r\n\r\n    // sets the angle and scale for the tilt element\r\n    const setTiltAngle = useCallback(\r\n      (angle: Angle, changeScale = true) => {\r\n        // Note: 'changeScale' is used to apply scale only on touch/hover and not on gyro\r\n        const currentScale = changeScale ? scale : 1;\r\n\r\n        requestAnimationFrame(() => {\r\n          if (tiltRef.current)\r\n            tiltRef.current.style.transform = `rotateX(${angle.angleX}deg) rotateY(${angle.angleY}deg) scale3d(${currentScale},${currentScale},${currentScale})`;\r\n        });\r\n\r\n        if (onTilt)\r\n          onTilt({\r\n            angleX: angle.angleX,\r\n            angleY: angle.angleY,\r\n          });\r\n      },\r\n      [onTilt, scale]\r\n    );\r\n\r\n    // sets currentPosition based on the provided angle,\r\n    // sets tilt angle to it and updates glare elements\r\n    const tilt = useCallback(\r\n      (angle: Angle, changeScale = false) => {\r\n        setOffsetFromAngle(angle);\r\n        setTiltAngle(angle, changeScale);\r\n        updateLineGlare();\r\n        updateSpotGlare();\r\n      },\r\n      [updateLineGlare, setOffsetFromAngle, updateSpotGlare, setTiltAngle]\r\n    );\r\n\r\n    // resets tilt angle, line glare transform,\r\n    // and spot glare transform/opacity\r\n    const reset = useCallback(() => {\r\n      // if initial angle is provided, set it as the current angle\r\n      if (initialAngleX || initialAngleY) {\r\n        const initialAngle: Angle = {\r\n          angleX: initialAngleX || 0,\r\n          angleY: initialAngleY || 0,\r\n        };\r\n        tilt(initialAngle);\r\n      } else {\r\n        offset.current = undefined;\r\n        // if we don't use requestAnimationFrame() here,\r\n        // the last mousemove/touchmove's requestAnimationFrame() call could\r\n        // run after this function and glares and tilt would not be reset.\r\n        requestAnimationFrame(() => {\r\n          if (lineGlareRef.current) {\r\n            lineGlareRef.current.style.transform = `translateX(${\r\n              !lineGlareReverse ? '-100%' : '50%'\r\n            })`;\r\n          }\r\n          if (spotGlareRef.current) {\r\n            spotGlareRef.current.style.transform = `translateX(0%)`;\r\n            spotGlareRef.current.style.opacity = '0';\r\n          }\r\n          if (tiltRef.current)\r\n            tiltRef.current.style.transform = `rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`;\r\n        });\r\n      }\r\n    }, [initialAngleX, initialAngleY, lineGlareReverse, tilt]);\r\n\r\n    // sets the offset value based on clinetX/Y\r\n    const setOffset = useCallback(\r\n      (position: Position, element: HTMLElement | Document | null) => {\r\n        if (!element) return;\r\n\r\n        // adding fullPageListening check so we don't have to\r\n        // run the \"instanceof\" check everytime if fullPageListening\r\n        // is false (which is the most common case)\r\n        if (fullPageListening && element instanceof Document) {\r\n          offset.current = {\r\n            offsetX: position.x / window.innerWidth,\r\n            offsetY: position.y / window.innerHeight,\r\n          };\r\n          return;\r\n        }\r\n\r\n        const boundingRect = (element as HTMLElement).getBoundingClientRect();\r\n\r\n        if (!boundingRect.width || !boundingRect.height) return;\r\n\r\n        const x = limitToRange(\r\n          position.x,\r\n          boundingRect.left,\r\n          boundingRect.right\r\n        );\r\n        const y = limitToRange(\r\n          position.y,\r\n          boundingRect.top,\r\n          boundingRect.bottom\r\n        );\r\n        const offsetX = (x - boundingRect.left) / boundingRect.width;\r\n        const offsetY = (y - boundingRect.top) / boundingRect.height;\r\n\r\n        offset.current = { offsetX, offsetY };\r\n      },\r\n      [fullPageListening]\r\n    );\r\n\r\n    // updates the \"will-change\" css property\r\n    const updateWillChange = useCallback((add = true) => {\r\n      if (tiltRef.current)\r\n        tiltRef.current.style.willChange = add ? 'transform' : '';\r\n      if (spotGlareRef.current)\r\n        spotGlareRef.current.style.willChange = add ? 'transform, opacity' : '';\r\n      if (lineGlareRef.current)\r\n        lineGlareRef.current.style.willChange = add ? 'transform' : '';\r\n    }, []);\r\n\r\n    // TiltRef\r\n    useImperativeHandle(\r\n      ref,\r\n      (): TiltRef => ({\r\n        tilt,\r\n        reset,\r\n        angle: () => getAngleFromOffset(false),\r\n        updateWillChange,\r\n        element: containerRef.current,\r\n      }),\r\n      [tilt, reset, updateWillChange, getAngleFromOffset]\r\n    );\r\n\r\n    // events\r\n\r\n    const mouseEnter = useCallback(() => {\r\n      if (disabled) return;\r\n      isBeingTouchedOrHovered.current = true;\r\n      updateWillChange();\r\n    }, [disabled, updateWillChange]);\r\n\r\n    const touchStart = useCallback(() => {\r\n      if (disabled) return;\r\n      // disable scroll on touch\r\n      if (disableScrollOnTouch && !fullPageListening) {\r\n        if (typeof disableScrollOnTouch === 'boolean')\r\n          document.body.style.overflow = 'hidden';\r\n        else disableScrollOnTouch.style.overflow = 'hidden';\r\n      }\r\n      isBeingTouchedOrHovered.current = true;\r\n      updateWillChange();\r\n    }, [disableScrollOnTouch, disabled, fullPageListening, updateWillChange]);\r\n\r\n    const mouseMove = useCallback(\r\n      (e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>) => {\r\n        if (disabled) return;\r\n        setOffset(\r\n          { x: e.clientX, y: e.clientY },\r\n          e.currentTarget as HTMLElement | Document\r\n        );\r\n        setTiltAngle(getAngleFromOffset());\r\n        updateLineGlare();\r\n        updateSpotGlare();\r\n      },\r\n      [\r\n        disabled,\r\n        getAngleFromOffset,\r\n        setOffset,\r\n        setTiltAngle,\r\n        updateLineGlare,\r\n        updateSpotGlare,\r\n      ]\r\n    );\r\n\r\n    const touchMove = useCallback(\r\n      (e: TouchEvent | React.TouchEvent<HTMLDivElement>) => {\r\n        if (disabled) return;\r\n        const Touch = e.changedTouches[0];\r\n        if (Touch) {\r\n          setOffset(\r\n            {\r\n              x: Touch.clientX,\r\n              y: Touch.clientY,\r\n            },\r\n            e.currentTarget as HTMLElement | Document\r\n          );\r\n          setTiltAngle(getAngleFromOffset());\r\n          updateLineGlare();\r\n          updateSpotGlare();\r\n        }\r\n      },\r\n      [\r\n        disabled,\r\n        getAngleFromOffset,\r\n        setOffset,\r\n        setTiltAngle,\r\n        updateLineGlare,\r\n        updateSpotGlare,\r\n      ]\r\n    );\r\n\r\n    const mouseLeave = useCallback(() => {\r\n      if (disabled) return;\r\n      isBeingTouchedOrHovered.current = false;\r\n      updateWillChange(false);\r\n      if (tiltReset) reset();\r\n    }, [disabled, reset, tiltReset, updateWillChange]);\r\n\r\n    const touchEnd = useCallback(() => {\r\n      if (disabled) return;\r\n      // enable scroll on touch\r\n      if (disableScrollOnTouch && !fullPageListening) {\r\n        if (typeof disableScrollOnTouch === 'boolean')\r\n          document.body.style.overflow = '';\r\n        else disableScrollOnTouch.style.overflow = '';\r\n      }\r\n      isBeingTouchedOrHovered.current = false;\r\n      updateWillChange(false);\r\n      if (tiltReset) reset();\r\n    }, [\r\n      disableScrollOnTouch,\r\n      disabled,\r\n      fullPageListening,\r\n      reset,\r\n      tiltReset,\r\n      updateWillChange,\r\n    ]);\r\n\r\n    const blur = useCallback(() => {\r\n      if (disabled) return;\r\n      reset();\r\n    }, [disabled, reset]);\r\n\r\n    // adding event listeners to controlElement(s)/document\r\n    useEffect(() => {\r\n      if (!controlElement && !fullPageListening) return;\r\n\r\n      // if controlElement is not an array, convert it to one\r\n      let controlElementArray: Array<\r\n        HTMLElement | RefObject<HTMLElement> | Document\r\n      >;\r\n      if (fullPageListening || !controlElement)\r\n        controlElementArray = [document];\r\n      else\r\n        controlElementArray = Array.isArray(controlElement)\r\n          ? controlElement\r\n          : [controlElement];\r\n\r\n      for (let el of controlElementArray) {\r\n        const convertedEl = getHTMLElement(el);\r\n        if (!convertedEl) continue;\r\n        el = convertedEl;\r\n\r\n        el.addEventListener('mouseenter', mouseEnter);\r\n        el.addEventListener('mousemove', mouseMove);\r\n        el.addEventListener('mouseleave', mouseLeave);\r\n        el.addEventListener('touchstart', touchStart, { passive: true });\r\n        el.addEventListener('touchmove', touchMove, { passive: true });\r\n        el.addEventListener('touchend', touchEnd, { passive: true });\r\n        el.addEventListener('blur', blur);\r\n      }\r\n\r\n      return () => {\r\n        for (let el of controlElementArray) {\r\n          const convertedEl = getHTMLElement(el);\r\n          if (!convertedEl) continue;\r\n          el = convertedEl;\r\n\r\n          el.removeEventListener('mouseenter', mouseEnter);\r\n          el.removeEventListener('mousemove', mouseMove);\r\n          el.removeEventListener('mouseleave', mouseLeave);\r\n          el.removeEventListener('touchstart', touchStart);\r\n          el.removeEventListener('touchmove', touchMove);\r\n          el.removeEventListener('touchend', touchEnd);\r\n          el.removeEventListener('blur', blur);\r\n        }\r\n      };\r\n    }, [\r\n      controlElement,\r\n      mouseEnter,\r\n      mouseMove,\r\n      mouseLeave,\r\n      touchStart,\r\n      touchMove,\r\n      touchEnd,\r\n      blur,\r\n      fullPageListening,\r\n    ]);\r\n\r\n    // device orientation event handler\r\n    const onDeviceOrientation = useCallback(\r\n      (e: DeviceOrientationEvent) => {\r\n        if (\r\n          isBeingTouchedOrHovered.current ||\r\n          (e.beta === null && e.gamma === null)\r\n        )\r\n          return;\r\n\r\n        let angleX =\r\n          gyroMaxAngleX && e.beta\r\n            ? limitToRange(e.beta, -gyroMaxAngleX, gyroMaxAngleX)\r\n            : initialAngleX || 0;\r\n        let angleY =\r\n          gyroMaxAngleY && e.gamma\r\n            ? limitToRange(e.gamma, -gyroMaxAngleY, gyroMaxAngleY)\r\n            : initialAngleY || 0;\r\n\r\n        if (gyroReverse) {\r\n          angleX = -angleX;\r\n          angleY = -angleY;\r\n        }\r\n\r\n        tilt({ angleX, angleY });\r\n      },\r\n      [\r\n        gyroMaxAngleX,\r\n        gyroMaxAngleY,\r\n        initialAngleX,\r\n        initialAngleY,\r\n        gyroReverse,\r\n        tilt,\r\n      ]\r\n    );\r\n\r\n    // adding device orientation event listener\r\n    useEffect(() => {\r\n      if (!gyroMaxAngleX && !gyroMaxAngleY) return;\r\n      window.addEventListener('deviceorientation', onDeviceOrientation);\r\n      return () =>\r\n        window.removeEventListener('deviceorientation', onDeviceOrientation);\r\n    }, [gyroMaxAngleX, gyroMaxAngleY, onDeviceOrientation, updateWillChange]);\r\n\r\n    return (\r\n      <div\r\n        ref={(el) => {\r\n          if (el) {\r\n            containerRef.current = el;\r\n            // if initial angle is provided or\r\n            // this is a re-render and currentPosition already has a value,\r\n            // reset position, tilt and glare elements\r\n            if (initialAngleX || initialAngleY || offset.current) reset();\r\n          }\r\n        }}\r\n        data-testid={testIdEnable ? 'container' : undefined}\r\n        style={Object.assign(\r\n          {\r\n            display: 'inline-block',\r\n            width,\r\n            height,\r\n            borderRadius,\r\n            perspective,\r\n            transformStyle: 'preserve-3d',\r\n            backfaceVisibility: 'hidden',\r\n            filter: disabled ? disabledFilter : undefined,\r\n          },\r\n          style\r\n        )}\r\n        onMouseEnter={\r\n          attachEvents\r\n            ? onMouseEnter\r\n              ? (e) => {\r\n                  mouseEnter();\r\n                  onMouseEnter(e);\r\n                }\r\n              : mouseEnter\r\n            : onMouseEnter\r\n        }\r\n        onTouchStart={\r\n          attachEvents\r\n            ? onTouchStart\r\n              ? (e) => {\r\n                  touchStart();\r\n                  onTouchStart(e);\r\n                }\r\n              : touchStart\r\n            : onTouchStart\r\n        }\r\n        onMouseMove={\r\n          attachEvents\r\n            ? onMouseMove\r\n              ? (e) => {\r\n                  mouseMove(e);\r\n                  onMouseMove(e);\r\n                }\r\n              : mouseMove\r\n            : onMouseMove\r\n        }\r\n        onTouchMove={\r\n          attachEvents\r\n            ? onTouchMove\r\n              ? (e) => {\r\n                  touchMove(e);\r\n                  onTouchMove(e);\r\n                }\r\n              : touchMove\r\n            : onTouchMove\r\n        }\r\n        onMouseLeave={\r\n          attachEvents\r\n            ? onMouseLeave\r\n              ? (e) => {\r\n                  mouseLeave();\r\n                  onMouseLeave(e);\r\n                }\r\n              : mouseLeave\r\n            : onMouseLeave\r\n        }\r\n        onTouchEnd={\r\n          attachEvents\r\n            ? onTouchEnd\r\n              ? (e) => {\r\n                  touchEnd();\r\n                  onTouchEnd(e);\r\n                }\r\n              : touchEnd\r\n            : onTouchEnd\r\n        }\r\n        onBlur={\r\n          attachEvents\r\n            ? onBlur\r\n              ? (e) => {\r\n                  blur();\r\n                  onBlur(e);\r\n                }\r\n              : blur\r\n            : onBlur\r\n        }\r\n        {...props}\r\n      >\r\n        <TiltWrapper>\r\n          <div\r\n            ref={tiltRef}\r\n            data-testid={testIdEnable ? 'tilt' : undefined}\r\n            style={Object.assign(\r\n              {\r\n                boxSizing: 'border-box',\r\n                position: 'relative',\r\n                width: '100%',\r\n                height: '100%',\r\n                borderRadius,\r\n                transformStyle: 'preserve-3d',\r\n                backfaceVisibility: 'hidden',\r\n                transition: CSSTransition,\r\n                transform: `rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,\r\n              },\r\n              tiltStyle\r\n            )}\r\n            {...tiltProps}\r\n          >\r\n            {children}\r\n            {spotGlareEnable && (\r\n              <div\r\n                data-testid={testIdEnable ? 'spot-glare-container' : undefined}\r\n                style={{\r\n                  pointerEvents: 'none',\r\n                  position: 'absolute',\r\n                  inset: '0',\r\n                  borderRadius,\r\n                  overflow: 'hidden',\r\n                  backfaceVisibility: 'hidden',\r\n                  mixBlendMode: spotGlareMixBlendMode,\r\n                }}\r\n              >\r\n                <div\r\n                  ref={spotGlareRef}\r\n                  data-testid={testIdEnable ? 'spot-glare' : undefined}\r\n                  style={{\r\n                    position: 'absolute',\r\n                    left: '-100%',\r\n                    top: '-100%',\r\n                    width: '200%',\r\n                    height: '200%',\r\n                    filter: lineGlareBlurEnable\r\n                      ? `blur(${lineGlareBlurAmount})`\r\n                      : undefined,\r\n                    transition: CSSTransition,\r\n                    backgroundImage: `radial-gradient(${spotGlareColor}, transparent)`,\r\n                    transform: 'translateX(0%)',\r\n                    opacity: '0',\r\n                  }}\r\n                />\r\n              </div>\r\n            )}\r\n            {lineGlareEnable && (\r\n              <div\r\n                data-testid={testIdEnable ? 'line-glare-container' : undefined}\r\n                style={{\r\n                  pointerEvents: 'none',\r\n                  position: 'absolute',\r\n                  inset: '0',\r\n                  borderRadius,\r\n                  overflow: 'hidden',\r\n                  backfaceVisibility: 'hidden',\r\n                  mixBlendMode: lineGlareMixBlendMode,\r\n                }}\r\n              >\r\n                <div\r\n                  data-testid={testIdEnable ? 'line-glare' : undefined}\r\n                  ref={lineGlareRef}\r\n                  style={{\r\n                    position: 'absolute',\r\n                    left: 0,\r\n                    top: '-50%',\r\n                    width: '200%',\r\n                    height: '200%',\r\n                    filter: lineGlareBlurEnable\r\n                      ? `blur(${lineGlareBlurAmount})`\r\n                      : '',\r\n                    transition: CSSTransition,\r\n                    opacity: String(lineGlareMaxOpacity),\r\n                    transform: `translateX(${\r\n                      !lineGlareReverse ? '-100%' : '50%'\r\n                    })`,\r\n                    backgroundImage: `linear-gradient(${\r\n                      lineGlareDirection === 'to-bottom-right'\r\n                        ? 'to bottom right'\r\n                        : 'to bottom left'\r\n                    }, transparent, transparent ${lineGlareStart}%, ${lineGlareColor} calc(${lineGlareStart}% + 1px), ${lineGlareColor} ${lineGlareEnd}%, transparent calc(${lineGlareEnd}% + 1px), transparent 0%)`,\r\n                  }}\r\n                />\r\n              </div>\r\n            )}\r\n          </div>\r\n        </TiltWrapper>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\nTilt.displayName = 'Tilt';\r\n\r\nexport default Tilt;\r\n"],"names":["f","require$$0","k","l","m","n","p","q","c","g","b","d","e","h","reactJsxRuntime_production_min","jsxRuntimeModule","limitToRange","num","start","end","getSpotGlareOpacity","offset","spotGlarePosition","spotGlareMaxOpacity","opacityNum","getSpotGlareTransform","spotGlareReverse","offsetX","offsetY","transform","getLineGlareTransform","lineGlareHoverPosition","lineGlareReverse","translateX","getHTMLElement","el","Tilt","forwardRef","width","height","borderRadius","perspective","scale","lineGlareEnable","lineGlareBlurEnable","lineGlareBlurAmount","lineGlareMaxOpacity","lineGlareWidthPercent","lineGlareMixBlendMode","lineGlareColor","lineGlareDirection","spotGlareEnable","spotGlareMixBlendMode","spotGlareColor","tiltMaxAngleX","tiltMaxAngleY","tiltReverse","tiltReset","initialAngleX","initialAngleY","disableScrollOnTouch","style","tiltStyle","tiltProps","gyroMaxAngleX","gyroMaxAngleY","gyroReverse","disabled","disabledFilter","CSSTransition","TiltWrapper","children2","jsx","Fragment","fullPageListening","controlElement","controlElementOnly","testIdEnable","onTilt","onMouseEnter","onMouseMove","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","onBlur","children","props","ref","useRef","isBeingTouchedOrHovered","attachEvents","containerRef","tiltRef","spotGlareRef","lineGlareRef","lineGlareStart","useMemo","lineGlareEnd","updateSpotGlare","useCallback","opacity","updateLineGlare","getAngleFromOffset","applyTiltReverse","angleX","angleY","setOffsetFromAngle","angle","setTiltAngle","changeScale","currentScale","tilt","reset","setOffset","position","element","boundingRect","x","y","updateWillChange","add","useImperativeHandle","mouseEnter","touchStart","mouseMove","touchMove","Touch","mouseLeave","touchEnd","blur","useEffect","controlElementArray","convertedEl","onDeviceOrientation","jsxs"],"mappings":"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","x_google_ignoreList":[0,1]}