{"version":3,"file":"Tilt.stories-46b7664a.js","sources":["../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react/jsx-runtime.js","../../src/lib/utility/utility.ts","../../src/lib/index.tsx"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","// react\r\nimport { RefObject } from 'react';\r\n\r\n// types\r\nimport {\r\n  SpotGlarePosition,\r\n  LineGlareHoverPosition,\r\n  Offset,\r\n} from '../types/types';\r\n\r\n// limits number to be in [start - end] range\r\nexport const limitToRange = (\r\n  num: number,\r\n  start: number,\r\n  end: number\r\n): number => {\r\n  if (num < start) return start;\r\n  if (num > end) return end;\r\n  return num;\r\n};\r\n\r\n// calculates opacity of the spot glare element\r\nexport const getSpotGlareOpacity = (\r\n  offset: Offset,\r\n  spotGlarePosition: SpotGlarePosition,\r\n  spotGlareMaxOpacity: number\r\n): string => {\r\n  let opacityNum = 0;\r\n\r\n  if (spotGlarePosition === 'top')\r\n    /*\r\n     *  when hovering from the top (offsetY = 0) to half of height (offsetY = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetY to opacity => [0 - 0.5] to [1 - 0]\r\n     *  * 2 = [0 - 1] -> - 1 = [-1 - 0] -> * -1 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetY * 2 - 1) * -1;\r\n  else if (spotGlarePosition === 'bottom')\r\n    /*\r\n     *  when hovering from the bottom (offsetY = 1) to half of height (offsetY = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetY to opacity => [1 - 0.5] to [1 - 0]\r\n     *  - 0.5 = [0.5 - 0] -> * 2 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetY - 0.5) * 2;\r\n  else if (spotGlarePosition === 'left')\r\n    /*\r\n     *  when hovering from the left (offsetX = 0) to half of width (offsetX = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetX to opacity => [0 - 0.5] to [1 - 0]\r\n     *  * 2 = [0 - 1] -> - 1 = [-1 - 0] -> * -1 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetX * 2 - 1) * -1;\r\n  else if (spotGlarePosition === 'right')\r\n    /*\r\n     *  when hovering from the right (offsetX = 1) to half of width (offsetX = 0.5)\r\n     *  the opacity should be going from fully visible (1) to transparent (0)\r\n     *  map offsetX to opacity => [1 - 0.5] to [1 - 0]\r\n     *  - 0.5 = [0.5 - 0] -> * 2 = [1 - 0]\r\n     */\r\n    opacityNum = (offset.offsetX - 0.5) * 2;\r\n  else if (spotGlarePosition === 'all')\r\n    /*\r\n     *  when hovering from the center (offsetX = 0.5) to the edges (offsetX = 0 or 1)\r\n     *  the opacity should be going from transparent (0) to fully visible (1)\r\n     *  for both offsetX = 0 and offsetX = 1, abs(offsetX - 0.5) is 0.5\r\n     *  so we need to map abs(offsetX - 0.5) to [0 - 1]\r\n     *  - 0.5 = [-0.5 - 0.5] => abs() = [0 - 0.5] => * 2 = [0 - 1]\r\n     *  after doing similar mapping for offsetY, we set the maximum\r\n     *  of the two numbers as the opacity.\r\n     */\r\n    opacityNum = Math.max(\r\n      Math.abs(offset.offsetX - 0.5) * 2,\r\n      Math.abs(offset.offsetY - 0.5) * 2\r\n    );\r\n\r\n  // limit opacity to spotGlareMaxOpacity\r\n  return (opacityNum * spotGlareMaxOpacity).toFixed(2);\r\n};\r\n\r\n// calculates position of the spot glare element\r\nexport const getSpotGlareTransform = (\r\n  offset: Offset,\r\n  spotGlarePosition: SpotGlarePosition,\r\n  spotGlareReverse: boolean\r\n): string => {\r\n  let offsetX = offset.offsetX;\r\n  let offsetY = offset.offsetY;\r\n\r\n  // reverse check\r\n  if (!spotGlareReverse) {\r\n    offsetX = 1 - offsetX;\r\n    offsetY = 1 - offsetY;\r\n  }\r\n\r\n  let transform = 'translateX(0%) translateY(0%)';\r\n\r\n  if (spotGlarePosition === 'top')\r\n    /*\r\n     *  when hovering from left (offsetX = 0) to right (ofsetX = 1)\r\n     *  translateX should be changing from 0 to 50% (because the spot glare element\r\n     *  is twice the size of the element and translate is relative to its size)\r\n     *  map offsetX to translateX => [0 - 1] to [0 - 50]\r\n     *  / 2 = [0 - 0.5] -> * 100 = [0 - 50] ->= ( * 50 )\r\n     */\r\n    transform = `translateX( ${offsetX * 50}% )`;\r\n  else if (spotGlarePosition === 'bottom')\r\n    // similar to above but translateY should be 50% to move it to the bottom\r\n    transform = `translateX( ${offsetX * 50}% ) translateY(50%)`;\r\n  else if (spotGlarePosition === 'left')\r\n    /*\r\n     *  when hovering from top (offsetY = 0) to bottom (ofsetY = 1)\r\n     *  translateY should be changing from 0 to 50% (because the glare element\r\n     *  is twice the size of the element and translate is relative to its size)\r\n     *  map offsetY to translateY => [0 - 1] to [0 - 50]\r\n     *  / 2 = [0 - 0.5] -> * 100 = [0 - 50] ->= ( * 50 )\r\n     */\r\n    transform = `translateY( ${offsetY * 50}% )`;\r\n  else if (spotGlarePosition === 'right')\r\n    // similar to above but translateX should be 50% to move it to the right\r\n    transform = `translateX(50%) translateY( ${offsetY * 50}% ) `;\r\n  else if (spotGlarePosition === 'all')\r\n    /*\r\n     *  for the 'all' postition, starting position is at the center\r\n     *  and when hovering from top to bottom (offsetY = [0 - 1]),\r\n     *  translateY should be chnaging from [-25% - 25%]\r\n     *  mapping [0 - 1] to [-25 - 25]\r\n     *  * -0.5 = [-0.5 - 0.5] => * 50 = [-25 - 25]\r\n     *  and similar mapping is applied to offsetX\r\n     * */\r\n    transform = `translateX(${(offsetX - 0.5) * 50}%) translateY(${\r\n      (offsetY - 0.5) * 50\r\n    }%) `;\r\n\r\n  return transform;\r\n};\r\n\r\n// calculates position of the spot glare element\r\nexport const getLineGlareTransform = (\r\n  offset: Offset,\r\n  lineGlareHoverPosition: LineGlareHoverPosition,\r\n  lineGlareReverse: boolean\r\n): string => {\r\n  let offsetX = offset.offsetX;\r\n  let offsetY = offset.offsetY;\r\n\r\n  // adjusting offsets based on hover position\r\n  if (lineGlareHoverPosition === 'top-right') offsetX = 1 - offsetX;\r\n  if (lineGlareHoverPosition === 'bottom-left') offsetY = 1 - offsetY;\r\n  if (lineGlareHoverPosition === 'bottom-right') {\r\n    offsetX = 1 - offsetX;\r\n    offsetY = 1 - offsetY;\r\n  }\r\n\r\n  let translateX = 0;\r\n\r\n  if (!lineGlareReverse)\r\n    /*\r\n     *  - line glare should be moving from translateX:-100% to 50% to\r\n     *    give the impression of moving over the element (since it's double the size\r\n     *    and translate is relative to size of the line glare not the parent element)\r\n     *\r\n     *  - the range of (offsetX + offsetY) is [0 - 2] but because line glare should\r\n     *    only be visible when hovering over the top-left part of the image,\r\n     *    we only need to map half the range ([0 - 1]).\r\n     *\r\n     *  - line glare should enter the element when hovering at center (offsetX + offsetY = 1),\r\n     *    and exit the element when hovering over the corner (offsetX + offsetY = 0), so\r\n     *    we need to map [1 - 0] to [-100 - 50] not [0 - 1].\r\n     *\r\n     *  - to map [1 - 0] to [-100 - 50]:\r\n     *    * -1 = [-1 - 0] -> * 3/2 = [-1.5 - 0] -> + 0.5 = [-1 - 0.5] -> * 100 = [-100 - 50]\r\n     */\r\n    translateX = ((offsetX + offsetY) * (-3 / 2) + 0.5) * 100;\r\n  /*\r\n   *  when reversed, we need to map [0 - 1] instead.\r\n   *  map [0 - 1] to [-100 - 50]:\r\n   *  * 3/2 = [0 - 1.5] -> - 1 = [-1 - 0.5] -> * 100 = [-100 - 50]\r\n   */ else translateX = ((offsetX + offsetY) * (3 / 2) - 1) * 100;\r\n\r\n  return `translateX(${translateX}%)`;\r\n};\r\n\r\n// gets HTMLElement from the union\r\nexport const getHTMLElement = (\r\n  el: HTMLElement | RefObject<HTMLElement> | Document\r\n): HTMLElement | undefined => {\r\n  // if it's an HTMLElement, return it\r\n  if (el instanceof HTMLElement) return el;\r\n\r\n  // if it's the document, case it to HTMLElement and return it\r\n  if (el instanceof Document) return document as unknown as HTMLElement;\r\n\r\n  // if it's a \"RefObject\" and \"ref.current\" is not null, return it\r\n  if (el.current) return el.current;\r\n\r\n  // otherwise, return undefined\r\n  return undefined;\r\n};\r\n\r\n// source: https://github.com/epoberezkin/fast-deep-equal/blob/master/src/index.jst\r\nexport const isDeepEqual = (a: any, b: any) => {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    let length, i;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0; ) if (!isDeepEqual(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n    if (a instanceof Map && b instanceof Map) {\r\n      if (a.size !== b.size) return false;\r\n      for (i of a.entries()) if (!b.has(i[0])) return false;\r\n      for (i of a.entries()) if (!isDeepEqual(i[1], b.get(i[0]))) return false;\r\n      return true;\r\n    }\r\n\r\n    if (a instanceof Set && b instanceof Set) {\r\n      if (a.size !== b.size) return false;\r\n      for (i of a.entries()) if (!b.has(i[0])) return false;\r\n      return true;\r\n    }\r\n\r\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\r\n      length = (a as any).length;\r\n      if (length != (a as any).length) return false;\r\n      for (i = length; i-- !== 0; )\r\n        if ((a as any)[i] !== (a as any)[i]) return false;\r\n      return true;\r\n    }\r\n\r\n    if (a.constructor === RegExp)\r\n      return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf)\r\n      return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString)\r\n      return a.toString() === b.toString();\r\n\r\n    const keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0; )\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0; ) {\r\n      const key = keys[i];\r\n\r\n      if (key === '_owner' && a.$$typeof) {\r\n        // React-specific: avoid traversing React elements' _owner.\r\n        //  _owner contains circular references\r\n        // and is not needed when comparing the actual elements (and not their owners)\r\n        continue;\r\n      }\r\n\r\n      if (!isDeepEqual(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a !== a && b !== b;\r\n};\r\n","// react\r\nimport {\r\n  useEffect,\r\n  useRef,\r\n  useCallback,\r\n  useMemo,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  PropsWithChildren,\r\n  RefObject,\r\n  memo,\r\n} from 'react';\r\n\r\n// utility\r\nimport {\r\n  limitToRange,\r\n  getSpotGlareOpacity,\r\n  getSpotGlareTransform,\r\n  getLineGlareTransform,\r\n  getHTMLElement,\r\n  isDeepEqual,\r\n} from './utility/utility';\r\n\r\n// types\r\nimport { TiltProps, TiltRef, Position, Angle, Offset } from './types/types';\r\n\r\nconst NextTilt = forwardRef<TiltRef, TiltProps>(\r\n  (\r\n    {\r\n      width,\r\n      height,\r\n      borderRadius,\r\n      perspective = '1000px',\r\n      scale = 1,\r\n      shadowEnable = false,\r\n      shadow = '0 0 1rem rgba(0,0,0,0.5)',\r\n      lineGlareEnable = true,\r\n      lineGlareBlurEnable = true,\r\n      lineGlareBlurAmount = '4px',\r\n      lineGlareMaxOpacity = 0.1,\r\n      lineGlareWidthPercent = 10,\r\n      lineGlareMixBlendMode = 'normal',\r\n      lineGlareColor = 'white',\r\n      lineGlareReverse = false,\r\n      lineGlareDirection = 'to-bottom-right',\r\n      lineGlareHoverPosition = 'top-left',\r\n      spotGlareEnable = true,\r\n      spotGlareMaxOpacity = 0.5,\r\n      spotGlareMixBlendMode = 'normal',\r\n      spotGlarePosition = 'top',\r\n      spotGlareColor = 'white',\r\n      spotGlareReverse = false,\r\n      tiltMaxAngleX = 20,\r\n      tiltMaxAngleY = 20,\r\n      tiltReverse = false,\r\n      tiltReset = true,\r\n      initialAngleX = 0,\r\n      initialAngleY = 0,\r\n      disableScrollOnTouch = true,\r\n      style,\r\n      tiltStyle,\r\n      tiltProps,\r\n      gyroMaxAngleX = 0,\r\n      gyroMaxAngleY = 0,\r\n      gyroReverse = false,\r\n      disabled = false,\r\n      disabledFilter = 'grayscale(1) brightness(125%)',\r\n      CSSTransition = 'all 0.4s cubic-bezier(0.03, 0.98, 0.52, 0.99)',\r\n      TiltWrapper,\r\n      fullPageListening = false,\r\n      controlElement,\r\n      controlElementOnly = false,\r\n      testIdEnable = false,\r\n      onTilt,\r\n      onMouseEnter,\r\n      onMouseMove,\r\n      onMouseLeave,\r\n      onTouchStart,\r\n      onTouchMove,\r\n      onTouchEnd,\r\n      children,\r\n      ...props\r\n    }: TiltProps,\r\n    ref\r\n  ) => {\r\n    // state variables (non-re-rendering)\r\n    const offset = useRef<Offset>();\r\n    const isBeingTouchedOrHovered = useRef(false);\r\n    const attachEvents =\r\n      !fullPageListening &&\r\n      (!controlElement || (controlElement && !controlElementOnly));\r\n\r\n    // elements\r\n    const containerRef = useRef<HTMLDivElement | null>(null);\r\n    const tiltRef = useRef<HTMLDivElement>(null);\r\n    const spotGlareRef = useRef<HTMLDivElement>(null);\r\n    const lineGlareRef = useRef<HTMLDivElement>(null);\r\n\r\n    // tilt wrapper component default\r\n    const TiltWrapperDefault = useCallback(\r\n      ({ children }: PropsWithChildren) => <>{children}</>,\r\n      []\r\n    );\r\n    const TiltWrapperComponent = TiltWrapper || TiltWrapperDefault;\r\n\r\n    // line glare width check\r\n    if (lineGlareEnable) {\r\n      // halving width because the percentage is applied to the\r\n      // line glare element which is twice the size\r\n      lineGlareWidthPercent = limitToRange(lineGlareWidthPercent, 0, 50) / 2;\r\n    }\r\n\r\n    // limit max angles to [0 - 90]\r\n    tiltMaxAngleX = limitToRange(tiltMaxAngleX, 0, 90);\r\n    tiltMaxAngleY = limitToRange(tiltMaxAngleY, 0, 90);\r\n    gyroMaxAngleX = limitToRange(gyroMaxAngleX, 0, 90);\r\n    gyroMaxAngleY = limitToRange(gyroMaxAngleY, 0, 90);\r\n\r\n    // limit initial angles to max angle\r\n    if (initialAngleX)\r\n      initialAngleX = limitToRange(\r\n        initialAngleX,\r\n        -tiltMaxAngleX,\r\n        tiltMaxAngleX\r\n      );\r\n    if (initialAngleY)\r\n      initialAngleY = limitToRange(\r\n        initialAngleY,\r\n        -tiltMaxAngleY,\r\n        tiltMaxAngleY\r\n      );\r\n\r\n    // line glare variables\r\n    const lineGlareStart = useMemo(() => {\r\n      return lineGlareEnable ? (100 - lineGlareWidthPercent) / 2 : 0;\r\n    }, [lineGlareEnable, lineGlareWidthPercent]);\r\n    const lineGlareEnd = useMemo(() => {\r\n      return lineGlareEnable ? lineGlareStart + lineGlareWidthPercent : 0;\r\n    }, [lineGlareEnable, lineGlareWidthPercent, lineGlareStart]);\r\n\r\n    // functions\r\n\r\n    // updates spot glare element's transform and opacity\r\n    const updateSpotGlare = useCallback((): void => {\r\n      if (!containerRef.current || !spotGlareRef.current || !offset.current)\r\n        return;\r\n\r\n      const opacity = getSpotGlareOpacity(\r\n        offset.current,\r\n        spotGlarePosition,\r\n        spotGlareMaxOpacity\r\n      );\r\n\r\n      const transform = getSpotGlareTransform(\r\n        offset.current,\r\n        spotGlarePosition,\r\n        spotGlareReverse\r\n      );\r\n\r\n      requestAnimationFrame(() => {\r\n        if (spotGlareRef.current) {\r\n          spotGlareRef.current.style.opacity = opacity;\r\n          spotGlareRef.current.style.transform = transform;\r\n        }\r\n      });\r\n    }, [spotGlarePosition, spotGlareMaxOpacity, spotGlareReverse]);\r\n\r\n    // updates line glare element's transform\r\n    const updateLineGlare = useCallback((): void => {\r\n      if (!containerRef.current || !lineGlareRef.current || !offset.current)\r\n        return;\r\n\r\n      const transform = getLineGlareTransform(\r\n        offset.current,\r\n        lineGlareHoverPosition,\r\n        lineGlareReverse\r\n      );\r\n\r\n      requestAnimationFrame(() => {\r\n        if (lineGlareRef.current)\r\n          lineGlareRef.current.style.transform = transform;\r\n      });\r\n    }, [lineGlareHoverPosition, lineGlareReverse]);\r\n\r\n    // calculates tilt angle from offset\r\n    const getAngleFromOffset = useCallback(\r\n      (applyTiltReverse = true): Angle => {\r\n        if (!containerRef.current || !offset.current)\r\n          return { angleX: 0, angleY: 0 };\r\n\r\n        // mapping offset to angle => [0 - 1] to [-angle - angle]\r\n        // - 0.5 = [-0.5 - 0.5] -> * 2 = [-1 - 1] -> * angle = [-angle - angle]\r\n        let angleX = -(offset.current.offsetY - 0.5) * 2 * tiltMaxAngleX;\r\n        let angleY = (offset.current.offsetX - 0.5) * 2 * tiltMaxAngleY;\r\n\r\n        if (tiltReverse && applyTiltReverse) {\r\n          angleX = -angleX;\r\n          angleY = -angleY;\r\n        }\r\n\r\n        return { angleX, angleY };\r\n      },\r\n      [tiltMaxAngleX, tiltMaxAngleY, tiltReverse]\r\n    );\r\n\r\n    // sets offset based on tilt angle\r\n    const setOffsetFromAngle = useCallback(\r\n      (angle: Angle): void => {\r\n        // mapping (angleX/Y / tiltMaxAngleX/Y) to offset = [-1 - 1] to [0 - 1]\r\n        // + 1 = [0 - 2] -> / 2 = [0 - 1]\r\n        const offsetX = (angle.angleY / tiltMaxAngleY + 1) / 2;\r\n        const offsetY = (-angle.angleX / tiltMaxAngleX + 1) / 2;\r\n\r\n        offset.current = { offsetX, offsetY };\r\n      },\r\n      [tiltMaxAngleX, tiltMaxAngleY]\r\n    );\r\n\r\n    // sets the angle and scale for the tilt element\r\n    const setTiltAngle = useCallback(\r\n      (angle: Angle, changeScale = true) => {\r\n        // Note: 'changeScale' is used to apply scale only on touch/hover and not on gyro\r\n        const currentScale = changeScale ? scale : 1;\r\n\r\n        requestAnimationFrame(() => {\r\n          if (tiltRef.current)\r\n            tiltRef.current.style.transform = `rotateX(${angle.angleX}deg) rotateY(${angle.angleY}deg) scale3d(${currentScale},${currentScale},${currentScale})`;\r\n        });\r\n\r\n        if (onTilt)\r\n          onTilt({\r\n            angleX: angle.angleX,\r\n            angleY: angle.angleY,\r\n          });\r\n      },\r\n      [onTilt, scale]\r\n    );\r\n\r\n    // sets currentPosition based on the provided angle,\r\n    // sets tilt angle to it and updates glare elements\r\n    const tilt = useCallback(\r\n      (angle: Angle, changeScale = false) => {\r\n        setOffsetFromAngle(angle);\r\n        setTiltAngle(angle, changeScale);\r\n        updateLineGlare();\r\n        updateSpotGlare();\r\n      },\r\n      [updateLineGlare, setOffsetFromAngle, updateSpotGlare, setTiltAngle]\r\n    );\r\n\r\n    // resets tilt angle, line glare transform,\r\n    // and spot glare transform/opacity\r\n    const reset = useCallback(() => {\r\n      // if initial angle is provided, set it as the current angle\r\n      if (initialAngleX || initialAngleY) {\r\n        const initialAngle: Angle = {\r\n          angleX: initialAngleX || 0,\r\n          angleY: initialAngleY || 0,\r\n        };\r\n        tilt(initialAngle);\r\n      } else {\r\n        offset.current = undefined;\r\n        // if we don't use requestAnimationFrame() here,\r\n        // the last mousemove/touchmove's requestAnimationFrame() call could\r\n        // run after this function and glares and tilt would not be reset.\r\n        requestAnimationFrame(() => {\r\n          if (lineGlareRef.current) {\r\n            lineGlareRef.current.style.transform = `translateX(${\r\n              !lineGlareReverse ? '-100%' : '50%'\r\n            })`;\r\n          }\r\n          if (spotGlareRef.current) {\r\n            spotGlareRef.current.style.transform =\r\n              'translateX(0%) translateY(0%)';\r\n            spotGlareRef.current.style.opacity = '0';\r\n          }\r\n          if (tiltRef.current)\r\n            tiltRef.current.style.transform = `rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`;\r\n        });\r\n      }\r\n    }, [initialAngleX, initialAngleY, lineGlareReverse, tilt]);\r\n\r\n    // sets the offset value based on clinetX/Y\r\n    const setOffset = useCallback(\r\n      (position: Position, element: HTMLElement | Document | null) => {\r\n        if (!element) return;\r\n\r\n        // adding fullPageListening check so we don't have to\r\n        // run the \"instanceof\" check everytime if fullPageListening\r\n        // is false (which is the most common case)\r\n        if (fullPageListening && element instanceof Document) {\r\n          offset.current = {\r\n            offsetX: position.x / window.innerWidth,\r\n            offsetY: position.y / window.innerHeight,\r\n          };\r\n          return;\r\n        }\r\n\r\n        const boundingRect = (element as HTMLElement).getBoundingClientRect();\r\n\r\n        if (!boundingRect.width || !boundingRect.height) return;\r\n\r\n        const x = limitToRange(\r\n          position.x,\r\n          boundingRect.left,\r\n          boundingRect.right\r\n        );\r\n        const y = limitToRange(\r\n          position.y,\r\n          boundingRect.top,\r\n          boundingRect.bottom\r\n        );\r\n        const offsetX = (x - boundingRect.left) / boundingRect.width;\r\n        const offsetY = (y - boundingRect.top) / boundingRect.height;\r\n\r\n        offset.current = { offsetX, offsetY };\r\n      },\r\n      [fullPageListening]\r\n    );\r\n\r\n    // updates the \"will-change\" css property\r\n    const updateWillChange = useCallback((add = true) => {\r\n      if (tiltRef.current)\r\n        tiltRef.current.style.willChange = add ? 'transform' : '';\r\n      if (spotGlareRef.current)\r\n        spotGlareRef.current.style.willChange = add ? 'transform, opacity' : '';\r\n      if (lineGlareRef.current)\r\n        lineGlareRef.current.style.willChange = add ? 'transform' : '';\r\n    }, []);\r\n\r\n    // updates the box-shadow css property on the tilt element\r\n    const updateBoxShadow = useCallback(\r\n      (add = true) => {\r\n        if (tiltRef.current && shadowEnable)\r\n          tiltRef.current.style.boxShadow = add ? shadow : '';\r\n      },\r\n      [shadow, shadowEnable]\r\n    );\r\n\r\n    // TiltRef\r\n    useImperativeHandle(\r\n      ref,\r\n      (): TiltRef => ({\r\n        tilt,\r\n        reset,\r\n        angle: () => getAngleFromOffset(false),\r\n        updateWillChange,\r\n        element: containerRef.current,\r\n      }),\r\n      [tilt, reset, updateWillChange, getAngleFromOffset]\r\n    );\r\n\r\n    // events\r\n\r\n    const mouseEnter = useCallback(() => {\r\n      if (disabled) return;\r\n      isBeingTouchedOrHovered.current = true;\r\n      updateWillChange();\r\n      updateBoxShadow();\r\n    }, [disabled, updateBoxShadow, updateWillChange]);\r\n\r\n    const touchStart = useCallback(() => {\r\n      if (disabled) return;\r\n      // disable scroll on touch\r\n      if (disableScrollOnTouch && !fullPageListening) {\r\n        if (typeof disableScrollOnTouch === 'boolean')\r\n          document.body.style.overflow = 'hidden';\r\n        else disableScrollOnTouch.style.overflow = 'hidden';\r\n      }\r\n      isBeingTouchedOrHovered.current = true;\r\n      updateWillChange();\r\n      updateBoxShadow();\r\n    }, [\r\n      disableScrollOnTouch,\r\n      disabled,\r\n      fullPageListening,\r\n      updateBoxShadow,\r\n      updateWillChange,\r\n    ]);\r\n\r\n    const mouseMove = useCallback(\r\n      (e: MouseEvent | React.MouseEvent<HTMLDivElement, MouseEvent>) => {\r\n        if (disabled) return;\r\n        setOffset(\r\n          { x: e.clientX, y: e.clientY },\r\n          e.currentTarget as HTMLElement | Document\r\n        );\r\n        setTiltAngle(getAngleFromOffset());\r\n        updateLineGlare();\r\n        updateSpotGlare();\r\n      },\r\n      [\r\n        disabled,\r\n        getAngleFromOffset,\r\n        setOffset,\r\n        setTiltAngle,\r\n        updateLineGlare,\r\n        updateSpotGlare,\r\n      ]\r\n    );\r\n\r\n    const touchMove = useCallback(\r\n      (e: TouchEvent | React.TouchEvent<HTMLDivElement>) => {\r\n        if (disabled) return;\r\n        const Touch = e.changedTouches[0];\r\n        if (Touch) {\r\n          setOffset(\r\n            {\r\n              x: Touch.clientX,\r\n              y: Touch.clientY,\r\n            },\r\n            e.currentTarget as HTMLElement | Document\r\n          );\r\n          setTiltAngle(getAngleFromOffset());\r\n          updateLineGlare();\r\n          updateSpotGlare();\r\n        }\r\n      },\r\n      [\r\n        disabled,\r\n        getAngleFromOffset,\r\n        setOffset,\r\n        setTiltAngle,\r\n        updateLineGlare,\r\n        updateSpotGlare,\r\n      ]\r\n    );\r\n\r\n    const mouseLeave = useCallback(() => {\r\n      if (disabled) return;\r\n      isBeingTouchedOrHovered.current = false;\r\n      updateWillChange(false);\r\n      updateBoxShadow(false);\r\n      if (tiltReset) reset();\r\n    }, [disabled, reset, tiltReset, updateBoxShadow, updateWillChange]);\r\n\r\n    const touchEnd = useCallback(() => {\r\n      if (disabled) return;\r\n      // enable scroll on touch\r\n      if (disableScrollOnTouch && !fullPageListening) {\r\n        if (typeof disableScrollOnTouch === 'boolean')\r\n          document.body.style.overflow = '';\r\n        else disableScrollOnTouch.style.overflow = '';\r\n      }\r\n      isBeingTouchedOrHovered.current = false;\r\n      updateWillChange(false);\r\n      updateBoxShadow(false);\r\n      if (tiltReset) reset();\r\n    }, [\r\n      disableScrollOnTouch,\r\n      disabled,\r\n      fullPageListening,\r\n      reset,\r\n      tiltReset,\r\n      updateBoxShadow,\r\n      updateWillChange,\r\n    ]);\r\n\r\n    // adding event listeners to controlElement(s)/document\r\n    useEffect(() => {\r\n      if (!controlElement && !fullPageListening) return;\r\n\r\n      // if controlElement is not an array, convert it to one\r\n      let controlElementArray: Array<\r\n        HTMLElement | RefObject<HTMLElement> | Document\r\n      >;\r\n      if (fullPageListening || !controlElement)\r\n        controlElementArray = [document];\r\n      else\r\n        controlElementArray = Array.isArray(controlElement)\r\n          ? controlElement\r\n          : [controlElement];\r\n\r\n      for (let el of controlElementArray) {\r\n        const convertedEl = getHTMLElement(el);\r\n        if (!convertedEl) continue;\r\n        el = convertedEl;\r\n\r\n        el.addEventListener('mouseenter', mouseEnter);\r\n        el.addEventListener('mousemove', mouseMove);\r\n        el.addEventListener('mouseleave', mouseLeave);\r\n        el.addEventListener('touchstart', touchStart, { passive: true });\r\n        el.addEventListener('touchmove', touchMove, { passive: true });\r\n        el.addEventListener('touchend', touchEnd, { passive: true });\r\n      }\r\n\r\n      return () => {\r\n        for (let el of controlElementArray) {\r\n          const convertedEl = getHTMLElement(el);\r\n          if (!convertedEl) continue;\r\n          el = convertedEl;\r\n\r\n          el.removeEventListener('mouseenter', mouseEnter);\r\n          el.removeEventListener('mousemove', mouseMove);\r\n          el.removeEventListener('mouseleave', mouseLeave);\r\n          el.removeEventListener('touchstart', touchStart);\r\n          el.removeEventListener('touchmove', touchMove);\r\n          el.removeEventListener('touchend', touchEnd);\r\n        }\r\n      };\r\n    }, [\r\n      controlElement,\r\n      mouseEnter,\r\n      mouseMove,\r\n      mouseLeave,\r\n      touchStart,\r\n      touchMove,\r\n      touchEnd,\r\n      fullPageListening,\r\n    ]);\r\n\r\n    // device orientation event handler\r\n    const onDeviceOrientation = useCallback(\r\n      (e: DeviceOrientationEvent) => {\r\n        if (\r\n          isBeingTouchedOrHovered.current ||\r\n          (e.beta === null && e.gamma === null)\r\n        )\r\n          return;\r\n\r\n        let angleX =\r\n          gyroMaxAngleX && e.beta\r\n            ? limitToRange(-e.beta, -gyroMaxAngleX, gyroMaxAngleX)\r\n            : initialAngleX || 0;\r\n        let angleY =\r\n          gyroMaxAngleY && e.gamma\r\n            ? limitToRange(e.gamma, -gyroMaxAngleY, gyroMaxAngleY)\r\n            : initialAngleY || 0;\r\n\r\n        if (gyroReverse) {\r\n          angleX = -angleX;\r\n          angleY = -angleY;\r\n        }\r\n\r\n        tilt({ angleX, angleY });\r\n      },\r\n      [\r\n        gyroMaxAngleX,\r\n        gyroMaxAngleY,\r\n        initialAngleX,\r\n        initialAngleY,\r\n        gyroReverse,\r\n        tilt,\r\n      ]\r\n    );\r\n\r\n    // adding device orientation event listener\r\n    useEffect(() => {\r\n      if (!gyroMaxAngleX && !gyroMaxAngleY) return;\r\n      window.addEventListener('deviceorientation', onDeviceOrientation);\r\n      return () =>\r\n        window.removeEventListener('deviceorientation', onDeviceOrientation);\r\n    }, [gyroMaxAngleX, gyroMaxAngleY, onDeviceOrientation, updateWillChange]);\r\n\r\n    return (\r\n      <div\r\n        ref={(el) => {\r\n          if (el) {\r\n            containerRef.current = el;\r\n            // if initial angle is set and this is not a re-render,\r\n            // set initial angle by calling reset\r\n            if ((initialAngleX || initialAngleY) && !offset.current) reset();\r\n          }\r\n        }}\r\n        data-testid={testIdEnable ? 'container' : undefined}\r\n        style={Object.assign(\r\n          {\r\n            display: 'inline-block',\r\n            width,\r\n            height,\r\n            borderRadius,\r\n            perspective,\r\n            transformStyle: 'preserve-3d',\r\n            backfaceVisibility: 'hidden',\r\n            filter: disabled ? disabledFilter : undefined,\r\n          },\r\n          style\r\n        )}\r\n        onMouseEnter={\r\n          attachEvents\r\n            ? onMouseEnter\r\n              ? (e) => {\r\n                  mouseEnter();\r\n                  onMouseEnter(e);\r\n                }\r\n              : mouseEnter\r\n            : onMouseEnter\r\n        }\r\n        onTouchStart={\r\n          attachEvents\r\n            ? onTouchStart\r\n              ? (e) => {\r\n                  touchStart();\r\n                  onTouchStart(e);\r\n                }\r\n              : touchStart\r\n            : onTouchStart\r\n        }\r\n        onMouseMove={\r\n          attachEvents\r\n            ? onMouseMove\r\n              ? (e) => {\r\n                  mouseMove(e);\r\n                  onMouseMove(e);\r\n                }\r\n              : mouseMove\r\n            : onMouseMove\r\n        }\r\n        onTouchMove={\r\n          attachEvents\r\n            ? onTouchMove\r\n              ? (e) => {\r\n                  touchMove(e);\r\n                  onTouchMove(e);\r\n                }\r\n              : touchMove\r\n            : onTouchMove\r\n        }\r\n        onMouseLeave={\r\n          attachEvents\r\n            ? onMouseLeave\r\n              ? (e) => {\r\n                  mouseLeave();\r\n                  onMouseLeave(e);\r\n                }\r\n              : mouseLeave\r\n            : onMouseLeave\r\n        }\r\n        onTouchEnd={\r\n          attachEvents\r\n            ? onTouchEnd\r\n              ? (e) => {\r\n                  touchEnd();\r\n                  onTouchEnd(e);\r\n                }\r\n              : touchEnd\r\n            : onTouchEnd\r\n        }\r\n        {...props}\r\n      >\r\n        <TiltWrapperComponent>\r\n          <div\r\n            ref={tiltRef}\r\n            data-testid={testIdEnable ? 'tilt' : undefined}\r\n            style={Object.assign(\r\n              {\r\n                boxSizing: 'border-box',\r\n                position: 'relative',\r\n                width: '100%',\r\n                height: '100%',\r\n                borderRadius,\r\n                transformStyle: 'preserve-3d',\r\n                backfaceVisibility: 'hidden',\r\n                transition: CSSTransition,\r\n                transform: `rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,\r\n              },\r\n              tiltStyle\r\n            )}\r\n            {...tiltProps}\r\n          >\r\n            {children}\r\n            {spotGlareEnable && (\r\n              <div\r\n                data-testid={testIdEnable ? 'spot-glare-container' : undefined}\r\n                style={{\r\n                  pointerEvents: 'none',\r\n                  position: 'absolute',\r\n                  inset: '0',\r\n                  borderRadius,\r\n                  overflow: 'hidden',\r\n                  backfaceVisibility: 'hidden',\r\n                  mixBlendMode: spotGlareMixBlendMode,\r\n                }}\r\n              >\r\n                <div\r\n                  ref={spotGlareRef}\r\n                  data-testid={testIdEnable ? 'spot-glare' : undefined}\r\n                  style={{\r\n                    position: 'absolute',\r\n                    left: spotGlarePosition === 'all' ? '-50%' : '-100%',\r\n                    top: spotGlarePosition === 'all' ? '-50%' : '-100%',\r\n                    width: '200%',\r\n                    height: '200%',\r\n                    transition: CSSTransition,\r\n                    backgroundImage: `radial-gradient(${spotGlareColor}, transparent)`,\r\n                    transform: 'translateX(0%) translateY(0%)',\r\n                    opacity: '0',\r\n                  }}\r\n                />\r\n              </div>\r\n            )}\r\n            {lineGlareEnable && (\r\n              <div\r\n                data-testid={testIdEnable ? 'line-glare-container' : undefined}\r\n                style={{\r\n                  pointerEvents: 'none',\r\n                  position: 'absolute',\r\n                  inset: '0',\r\n                  borderRadius,\r\n                  overflow: 'hidden',\r\n                  backfaceVisibility: 'hidden',\r\n                  mixBlendMode: lineGlareMixBlendMode,\r\n                }}\r\n              >\r\n                <div\r\n                  data-testid={testIdEnable ? 'line-glare' : undefined}\r\n                  ref={lineGlareRef}\r\n                  style={{\r\n                    position: 'absolute',\r\n                    left: 0,\r\n                    top: '-50%',\r\n                    width: '200%',\r\n                    height: '200%',\r\n                    filter: lineGlareBlurEnable\r\n                      ? `blur(${lineGlareBlurAmount})`\r\n                      : '',\r\n                    transition: CSSTransition,\r\n                    opacity: String(lineGlareMaxOpacity),\r\n                    transform: `translateX(${\r\n                      !lineGlareReverse ? '-100%' : '50%'\r\n                    })`,\r\n                    backgroundImage: `linear-gradient(${\r\n                      lineGlareDirection === 'to-bottom-right'\r\n                        ? 'to bottom right'\r\n                        : 'to bottom left'\r\n                    }, transparent, transparent ${lineGlareStart}%, ${lineGlareColor} calc(${lineGlareStart}% + 1px), ${lineGlareColor} ${lineGlareEnd}%, transparent calc(${lineGlareEnd}% + 1px), transparent 0%)`,\r\n                  }}\r\n                />\r\n              </div>\r\n            )}\r\n          </div>\r\n        </TiltWrapperComponent>\r\n      </div>\r\n    );\r\n  }\r\n);\r\n\r\nexport const Tilt = memo(NextTilt, (prevProps, nextProps) =>\r\n  isDeepEqual(prevProps, nextProps)\r\n);\r\n\r\nTilt.displayName = 'Tilt';\r\n\r\nexport default Tilt;\r\n"],"names":["f","require$$0","k","l","m","n","p","q","c","a","g","b","d","e","h","reactJsxRuntime_production_min","jsxRuntimeModule","limitToRange","num","start","end","getSpotGlareOpacity","offset","spotGlarePosition","spotGlareMaxOpacity","opacityNum","getSpotGlareTransform","spotGlareReverse","offsetX","offsetY","transform","getLineGlareTransform","lineGlareHoverPosition","lineGlareReverse","translateX","getHTMLElement","el","isDeepEqual","length","i","keys","key","NextTilt","forwardRef","width","height","borderRadius","perspective","scale","shadowEnable","shadow","lineGlareEnable","lineGlareBlurEnable","lineGlareBlurAmount","lineGlareMaxOpacity","lineGlareWidthPercent","lineGlareMixBlendMode","lineGlareColor","lineGlareDirection","spotGlareEnable","spotGlareMixBlendMode","spotGlareColor","tiltMaxAngleX","tiltMaxAngleY","tiltReverse","tiltReset","initialAngleX","initialAngleY","disableScrollOnTouch","style","tiltStyle","tiltProps","gyroMaxAngleX","gyroMaxAngleY","gyroReverse","disabled","disabledFilter","CSSTransition","TiltWrapper","fullPageListening","controlElement","controlElementOnly","testIdEnable","onTilt","onMouseEnter","onMouseMove","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","children","props","ref","useRef","isBeingTouchedOrHovered","attachEvents","containerRef","tiltRef","spotGlareRef","lineGlareRef","TiltWrapperDefault","useCallback","children2","jsx","Fragment","TiltWrapperComponent","lineGlareStart","useMemo","lineGlareEnd","updateSpotGlare","opacity","updateLineGlare","getAngleFromOffset","applyTiltReverse","angleX","angleY","setOffsetFromAngle","angle","setTiltAngle","changeScale","currentScale","tilt","reset","setOffset","position","element","boundingRect","x","y","updateWillChange","add","updateBoxShadow","useImperativeHandle","mouseEnter","touchStart","mouseMove","touchMove","Touch","mouseLeave","touchEnd","useEffect","controlElementArray","convertedEl","onDeviceOrientation","jsxs","Tilt","memo","prevProps","nextProps"],"mappings":"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","x_google_ignoreList":[0,1]}